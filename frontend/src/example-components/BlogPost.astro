---
/* this is the root layout rendered for blog posts at /posts/[...slug] */
import type { CollectionEntry } from "astro:content";
import type { MarkdownHeading } from "astro";

import Masthead from "@/components/blog/Masthead.astro";
import TOC from "@/components/blog/TOC.astro";
import PostCard from "@/components/blog/PostCard.astro";
import ShareButtons from "@/components/blog/ShareButtons.astro";
import ToggleAllCodeBlocksButton from "@/components/ToggleAllCodeBlocksButton.svelte";

import BaseLayout from "./Base.astro";

interface Props {
	post: CollectionEntry<"post">;
	headings: MarkdownHeading[];
	previousPost?: CollectionEntry<"post"> | null;
	nextPost?: CollectionEntry<"post"> | null;
	relatedPosts?: CollectionEntry<"post">[];
}

const { post, headings, previousPost, nextPost, relatedPosts } = Astro.props;
const {
	data: { description, ogImage, publishDate, title, updatedDate, audience },
	id,
} = post;
const slug = id.replace(/\.[^/.]+$/, "");
const socialImage = ogImage ?? `/og-image/${slug}.png`;
const articleDate = updatedDate?.toISOString() ?? publishDate.toISOString();
const pageUrl = new URL(Astro.url.pathname, Astro.site).href;
---

<BaseLayout meta={{ articleDate, description, ogImage: socialImage, title }}>
	<div class="break-words" data-audience={audience}>
		{!!headings.length && <TOC headings={headings} />}
		<article class="flex-grow break-words" data-pagefind-body>
			<!-- back button -->
			<button
				id="back-btn"
				class="focus-outline mb-2 mt-2 flex max-w-fit items-center text-quote hover:text-accent hover:opacity-75"
			>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					class="h-6 w-6"
					stroke="currentColor"
					stroke-width="2"
				>
					<path d="M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z"></path>
				</svg><span>Go back</span>
			</button>
			<!-- masthead -->
			<div id="blog-hero"><Masthead content={post} /></div>
			<!-- share buttons -->
			<ShareButtons url={pageUrl} title={title} />
			{audience !== "technical" && <ToggleAllCodeBlocksButton client:load audience={audience} />}
			<!-- prose-headings: cf. https://github.com/tailwindlabs/tailwindcss-typography/blob/main/README.md -->
			<div
				class="prose prose-base prose-cactus mx-auto mt-12 sm:prose-lg prose-headings:font-semibold prose-headings:text-accent-2 sm:prose-th:before:content-none"
			>
				<slot />
			</div>

			<!-- Next and Previous Post Navigation -->
			{
				(nextPost || previousPost) && (
					<div class="mt-16 border-t border-textColor/10 pt-12">
						<div class="grid grid-cols-1 gap-8 md:grid-cols-2">
							{/* Previous Post */}
							{previousPost ? (
								<div>
									<h2 class="mb-4 text-lg font-semibold">← Previous Post</h2>
									<PostCard post={previousPost} />
								</div>
							) : (
								<div />
							)}

							{/* Next Post */}
							{nextPost ? (
								<div>
									<h2 class="mb-4 text-lg font-semibold">Next Post →</h2>
									<PostCard post={nextPost} />
								</div>
							) : (
								<div />
							)}
						</div>
					</div>
				)
			}

			<!-- Related Posts -->
			{
				relatedPosts && relatedPosts.length > 0 && (
					<div class="mt-16 border-t border-textColor/10 pt-12">
						<h2 class="mb-6 text-lg font-semibold">Related Posts</h2>
						<div class="space-y-6">
							{relatedPosts.map((post) => (
								<PostCard post={post} />
							))}
						</div>
					</div>
				)
			}
		</article>
	</div>
	<button
		aria-label="Back to Top"
		class="fixed bottom-8 end-4 z-10 flex h-10 w-10 translate-y-28 items-center justify-center rounded-full border-2 border-transparent bg-zinc-200/80 text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 dark:bg-zinc-700/80 sm:end-8 sm:h-12 sm:w-12"
		data-show="false"
		id="to-top-btn"
		><svg
			aria-hidden="true"
			class="h-6 w-6"
			fill="none"
			focusable="false"
			stroke="currentColor"
			stroke-width="2"
			viewBox="0 0 24 24"
			xmlns="http://www.w3.org/2000/svg"
		>
			<path d="M4.5 15.75l7.5-7.5 7.5 7.5" stroke-linecap="round" stroke-linejoin="round"></path>
		</svg>
	</button>
</BaseLayout>

<script>
	/** Handle back button navigation */
	function handleBackNavigation() {
		const backBtn = document.getElementById("back-btn") as HTMLButtonElement;
		backBtn.addEventListener("click", () => {
			// If there's no history, go to home
			if (window.history.length <= 1) {
				window.location.href = "/";
				return;
			}

			// Otherwise go back one step
			window.history.back();
		});
	}
	handleBackNavigation();

	/** Scroll to top button */
	const scrollBtn = document.getElementById("to-top-btn") as HTMLButtonElement;
	const targetHeader = document.getElementById("blog-hero") as HTMLDivElement;

	function callback(entries: IntersectionObserverEntry[]) {
		entries.forEach((entry) => {
			// only show the scroll to top button when the heading is out of view
			scrollBtn.dataset.show = (!entry.isIntersecting).toString();
		});
	}

	scrollBtn.addEventListener("click", () => {
		document.documentElement.scrollTo({ behavior: "smooth", top: 0 });
	});

	const observer = new IntersectionObserver(callback);
	observer.observe(targetHeader);

	/** Attaches links to headings in the document,
	 *  allowing sharing of sections easily */
	function addHeadingLinks() {
		const headings = Array.from(document.querySelectorAll("h2, h3, h4, h5, h6"));
		for (const heading of headings as HTMLElement[]) {
			heading.classList.add("group");

			// Create the link element
			const link = document.createElement("a");
			link.className = "inline-flex items-center no-underline text-inherit hover:text-inherit";
			link.href = "#" + heading.id;

			// Move the heading's content into the link
			link.innerHTML = heading.innerHTML;
			heading.innerHTML = "";

			// Add the hash symbol
			const hashSpan = document.createElement("span");
			hashSpan.ariaHidden = "true";
			hashSpan.className = "text-accent ml-2 opacity-0 group-hover:opacity-100 focus:opacity-100";
			hashSpan.innerText = "#";
			link.appendChild(hashSpan);

			// Add the link back to the heading
			heading.appendChild(link);
		}
	}
	addHeadingLinks();

	/** Create a progress indicator
	 *  at the top */
	function createProgressBar() {
		// Create the main container div
		const progressContainer = document.createElement("div");
		progressContainer.className =
			"progress-container fixed top-0 left-0 z-10 h-1 w-screen bg-bgColor";

		// Create the progress bar div
		const progressBar = document.createElement("div");
		progressBar.className = "progress-bar h-1 w-0 bg-accent";
		progressBar.id = "myBar";

		// Append the progress bar to the progress container
		progressContainer.appendChild(progressBar);

		// Append the progress container to the document body or any other desired parent element
		document.body.appendChild(progressContainer);
	}
	createProgressBar();

	/** Update the progress bar
	 *  when user scrolls */
	function updateScrollProgress() {
		document.addEventListener("scroll", () => {
			const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
			const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
			const scrolled = (winScroll / height) * 100;
			if (document) {
				const myBar = document.getElementById("myBar");
				if (myBar) {
					myBar.style.width = scrolled + "%";
				}
			}
		});
	}
	updateScrollProgress();

	/** Initialize PhotoSwipe lightbox for images */
	import PhotoSwipeLightbox from "photoswipe/lightbox";
	import PhotoSwipe from "photoswipe";
	import "photoswipe/style.css";

	let lightbox: PhotoSwipeLightbox | null = null;

	function initPhotoSwipe() {
		// Destroy previous instance if exists
		if (lightbox) {
			lightbox.destroy();
			lightbox = null;
		}

		// Get all triggers and de-duplicate based on image src
		const article = document.querySelector("article");
		if (!article) return;

		const allTriggers = article.querySelectorAll(".lightbox-trigger");
		const seenSrcs = new Set<string>();
		const uniqueTriggers: Element[] = [];

		// Map from src to index for duplicate handling
		const srcToIndex = new Map<string, number>();

		allTriggers.forEach((trigger) => {
			const href = trigger.getAttribute("href");
			if (href && !seenSrcs.has(href)) {
				srcToIndex.set(href, uniqueTriggers.length);
				seenSrcs.add(href);
				uniqueTriggers.push(trigger);
			} else if (href) {
				// Mark duplicate and store original index for click handling
				trigger.classList.add("lightbox-duplicate");
				trigger.setAttribute("data-pswp-original-index", String(srcToIndex.get(href)));
			}
		});

		lightbox = new PhotoSwipeLightbox({
			gallery: "article",
			// Only include non-duplicate triggers
			children: ".lightbox-trigger:not(.lightbox-duplicate)",
			pswpModule: PhotoSwipe,
		});
		lightbox.init();

		// Handle clicks on duplicate triggers - open lightbox at original image
		article.querySelectorAll(".lightbox-duplicate").forEach((dup) => {
			dup.addEventListener("click", (e) => {
				e.preventDefault();
				const index = parseInt(dup.getAttribute("data-pswp-original-index") || "0", 10);
				lightbox?.loadAndOpen(index);
			});
		});
	}

	// Initialize on first load and on Astro view transitions
	initPhotoSwipe();
	document.addEventListener("astro:page-load", initPhotoSwipe);
</script>
